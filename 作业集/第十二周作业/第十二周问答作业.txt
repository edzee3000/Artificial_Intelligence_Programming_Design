

第一问：如何逐元素加法
根据广播的原则，从后往前逐一匹配，对于数组A与数组B最后一个元素为5，得以匹配；然后再匹配倒数第2个元素，发现A是1，B是3，
因此A的1应当广播成3；然后再比较倒数第三个元素这个时候数组B没有更高的axis因此会扩展一个axis并且与A进行相应的匹配成3，
因此最后的数组形状为(3,3,5)，将扩展之后的数组A与数组B再逐一进行加法操作。

第二问：数组乘法
在两个ndarray数组运算过程中，先会进行从右往左的匹配操作，当两个维度长度相等或者其中一个为1时，两者compatible，
当其中一个矩阵维度不足时，用长度为1的新维度进行补充。而广播则是将长度为1的维度内容复制匹配另一矩阵对应长度
对于维度为(2,1)数组A与维度为(1,3)数组B，从右往左匹配的时候发现都可以匹配的上，接下来进行广播，将A的1广播为3，
B的1广播为2都形成(2,3)的数组，然后逐元素进行multiply操作，最终结果数组形状为(2,3)
假设数组A为[[a11],[a21]]，数组B形状为[[b11,b12,b13]]，广播之后分别为[[a11,a11,a11],[a21,a21,a21]]
[[b11,b12,b13],[b11,b12,b13]]，则最终结果为[[a11*b11,a11*b12,a11*b13],[a21*b11,a21*b12,a21*b13]]

第三问：行主序与列主序
结果很明显，按行访问的时间效率远远高于按列访问的时间效率
为什么会有性能差异：在内部存储当中，numpy实际上是按照一行进行存储的，实际上就是一个一维数组，
而计算机每一次从内存读取数据的时候都是先读一段到缓存当中（cpu当中的寄存机），由于时间重复性与空间重复性
（即被访问的元素接下被再次访问到的概率更高，以及被访问的元素下面的元素被访问的概率也更高）因此同一行的元素被读进寄存器当中，
如果按行进行访问的话每一次访问直接往下偏移即可，而如果按列进行访问的话，每一次又要从内存当中把下一行的数组读进寄存器当中，
会大大降低时间效率


第四问：聚合函数
聚合函数内部实现机制：
NumPy的聚合函数有如np.mean、np.sum、np.max等，是NumPy中非常强大和常用的功能。
这些函数可以沿着数组的指定轴进行操作，并且能够有效地处理多维数据。
在内部实现上，这些NumPy聚合函数主要使用C语言编写，使得它能够高效地处理数组运算。
当在多维数组上应用聚合函数时，NumPy会根据axis参数的值来确定如何遍历数组。
axis参数指定了操作的轴，即沿着哪个维度进行聚合。
NumPy内部存储当然是以一维数组去存储，并通过strides来确定访问某个元素的时候需要跳过多少个元素才能访问的到
如何指定axis参数：

对于形状为(3,4,5)的三维数组
如果要按照axis=0进行聚合，确定strides为(20,5,1)，
然后根据0,1,2对3个(4,5)的块进行遍历累加求平均值（这里默认是跳过多少个元素而不是跳过多少个字节）
最后变成一个(4,5)的二维数组；
如果要按照axis=1进行聚合，对4个(3,5)的块进行遍历累加；
如果要按照axis=2进行聚合，对5个(3,4)的块进行遍历累加

在内部，NumPy使用了一种strider步进器来遍历数组。
步进器是一种包含数组元数据和如何遍历数组的信息的数据结构，
当一个聚合函数被调用时，NumPy会创建一个步进器来遍历数组，
对于每个轴，步进器会计算该轴的步长strides跳过多少个元素到达下一个沿着该轴的元素，
在多维数组中，步进器会根据axis参数来确定如何遍历数组








